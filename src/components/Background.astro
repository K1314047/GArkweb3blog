<canvas id="background-canvas"></canvas>

<style>
  #background-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: -1;
    pointer-events: none;
  }
</style>

<script>
  const canvas = document.getElementById('background-canvas');
  if (canvas) {
    const ctx = canvas.getContext('2d');
    let width, height;
    let circles = [];
    let animationId;
    let time = 0;

    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      initCircles();
    }

    function initCircles() {
      circles = [];
      const count = 4;
      for (let i = 0; i < count; i++) {
        const isLeft = i < count / 2;
        // 将圆心限制在两侧区域
        const xMin = isLeft ? -width * 0.2 : width * 0.8;
        const xMax = isLeft ? width * 0.2 : width * 1.2;
        
        circles.push({
          isLeft,
          x: xMin + Math.random() * (xMax - xMin),
          y: Math.random() * height,
          baseR: Math.min(width, height) * (0.25 + Math.random() * 0.35),
          dx: (Math.random() - 0.5) * 0.2, // 稍微降低速度
          dy: (Math.random() - 0.5) * 0.2,
          phase: Math.random() * Math.PI * 2,
          breathSpeed: 0.008 + Math.random() * 0.006,
          breathAmp: 0.03 + Math.random() * 0.02,
        });
      }
    }

    function draw() {
      if (!canvas.isConnected) {
        cancelAnimationFrame(animationId);
        return;
      }

      ctx.clearRect(0, 0, width, height);
      time += 1;
      
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark' || 
                     (!document.documentElement.hasAttribute('data-theme') && window.matchMedia('(prefers-color-scheme: dark)').matches);

      if (isDark) {
        animationId = requestAnimationFrame(draw);
        return;
      }

      circles.forEach((circle, index) => {
        const breathOffset = Math.sin(time * circle.breathSpeed + circle.phase) * circle.breathAmp;
        const currentR = circle.baseR * (1 + breathOffset);
        
        // 降低透明度，使其更不显眼
        const alphaBase = 0.15 + index * 0.05;
        const alphaOffset = Math.sin(time * circle.breathSpeed + circle.phase) * 0.05;
        
        ctx.beginPath();
        ctx.arc(circle.x, circle.y, currentR, 0, Math.PI * 2);
        ctx.strokeStyle = '#E3E3E3';
        ctx.lineWidth = 1;
        ctx.globalAlpha = Math.max(0, alphaBase + alphaOffset);
        ctx.stroke();

        circle.x += circle.dx;
        circle.y += circle.dy;

        // 限制在两侧区域反弹
        const xLimit = width * 0.3; // 允许稍微进入中间区域
        if (circle.isLeft) {
          if (circle.x < -width * 0.3) circle.dx = Math.abs(circle.dx);
          if (circle.x > xLimit) circle.dx = -Math.abs(circle.dx);
        } else {
          if (circle.x < width - xLimit) circle.dx = Math.abs(circle.dx);
          if (circle.x > width * 1.3) circle.dx = -Math.abs(circle.dx);
        }
        
        if (circle.y < -currentR * 0.5) circle.dy = Math.abs(circle.dy);
        if (circle.y > height + currentR * 0.5) circle.dy = -Math.abs(circle.dy);
      });

      animationId = requestAnimationFrame(draw);
    }

    window.addEventListener('resize', resize);
    resize();
    draw();
  }
</script>
